// TODO tune built-in attributes
// From https://doc.rust-lang.org/reference/items/modules.html#attributes-on-modules
// The built-in attributes that have meaning on a module are cfg, deprecated, doc,
// the lint check attributes, path, and no_implicit_prelude.
// Modules also accept macro attributes.

#[macro_use]
extern crate clap;

use clap::Parser;

mod consts;
mod cyclone_dx;
mod errors;
mod logger;
mod nix;
mod sbom;
mod utils;

/// nix2sbom extracts the SBOM (Software Bill of Materials) from a Nix derivation
#[derive(Parser)]
#[clap(name = crate::consts::PROJECT_NAME)]
#[clap(version = env!("CARGO_PKG_VERSION"))]
#[clap(about = "nix2sbom extracts the SBOM (Software Bill of Materials) from a Nix derivation", long_about = None)]
struct NixToSBOM {
    /// Path of the file to extract a SBOM manifest from.
    #[clap(long, short)]
    file_path: Option<String>,

    /// Output format for the SBOM manifest. Defaults to cdx (CycloneDX).
    #[clap(long)]
    format: Option<String>,

    /// Which format to use for serializing the SBOM. CycloneDX supports yaml and json.
    #[clap(short, long)]
    serialization_format: Option<String>,

    /// Path of an existing package metadata file.
    ///
    /// This file can be generated by using the following command:
    /// nix-env -q -a --meta --json '.*'
    #[clap(long)]
    metadata_path: Option<String>,

    /// Do not use the metadata from the store to generate the SBOM.
    #[clap(long, short)]
    no_meta: bool,

    /// Generate a SBOM for the current system.
    #[clap(long, short)]
    current_system: bool,
}

fn main() -> Result<std::process::ExitCode, Box<dyn std::error::Error>> {
    logger::init();
    let args = NixToSBOM::parse();

    let output_format = match args.format {
        Some(f) => match crate::sbom::Format::from_string(&f) {
            Some(f) => f,
            None => {
                eprintln!("Invalid format {}", &f);
                return Ok(std::process::ExitCode::FAILURE);
            }
        },
        None => crate::sbom::Format::default(),
    };

    let serialization_format = match args.serialization_format {
        Some(f) => match crate::sbom::SerializationFormat::from_string(&f) {
            Some(f) => f,
            None => {
                eprintln!("Invalid serialization format {}", &f);
                return Ok(std::process::ExitCode::FAILURE);
            }
        },
        None => output_format.get_default_serialization_format(),
    };

    let mut derivations: crate::nix::Derivations = crate::nix::Derivations::default();
    if let Some(file_path) = args.file_path {
        log::info!("Getting the derivations from {}", &file_path);
        derivations = nix::Derivation::get_derivations(&file_path)?;
    } else if args.current_system {
        log::info!("Getting the derivations from the current system");
        derivations = nix::Derivation::get_derivations_for_current_system()?;
    } else {
        eprintln!("Error: Must provide a file or use the --curent-system argument");
        return Ok(std::process::ExitCode::FAILURE);
    }
    log::info!("Found {} derivations", derivations.len());

    let packages = crate::nix::get_packages(args.metadata_path, args.no_meta)?;
    log::debug!("Found {} packages in the Nix store", packages.len());

    log::info!("Building the package graph");
    let package_graph = crate::nix::get_package_graph(&derivations, &packages);
    log::info!("{} nodes in the package graph", package_graph.len());

    log::info!("Creating the SBOM");

    let sbom_dump = match output_format.dump(&serialization_format, &package_graph) {
        Ok(d) => d,
        Err(e) => {
            eprintln!("{}", e.to_string());
            return Ok(std::process::ExitCode::FAILURE);
        }
    };

    println!("{}", sbom_dump);

    Ok(std::process::ExitCode::SUCCESS)
}
